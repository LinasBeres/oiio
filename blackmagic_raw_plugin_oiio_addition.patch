diff -ruN '--exclude=.git' oiio-2.0.10/src/braw.imageio/BlackmagicRawAPIDispatch.cpp oiio/src/braw.imageio/BlackmagicRawAPIDispatch.cpp
--- oiio-2.0.10/src/braw.imageio/BlackmagicRawAPIDispatch.cpp	1970-01-01 01:00:00.000000000 +0100
+++ oiio/src/braw.imageio/BlackmagicRawAPIDispatch.cpp	2020-02-18 14:33:41.091257463 +0000
@@ -0,0 +1,297 @@
+/* -LICENSE-START-
+** Copyright (c) 2018 Blackmagic Design
+**
+** Permission is hereby granted, free of charge, to any person or organization
+** obtaining a copy of the software and accompanying documentation covered by
+** this license (the "Software") to use, reproduce, display, distribute,
+** execute, and transmit the Software, and to prepare derivative works of the
+** Software, and to permit third-parties to whom the Software is furnished to
+** do so, all subject to the following:
+**
+** The copyright notices in the Software and this entire statement, including
+** the above license grant, this restriction and the following disclaimer,
+** must be included in all copies of the Software, in whole or in part, and
+** all derivative works of the Software, unless such copies or derivative
+** works are solely in the form of machine-executable object code generated by
+** a source language processor.
+**
+** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+** DEALINGS IN THE SOFTWARE.
+** -LICENSE-END-
+**/
+
+#include <stdio.h>
+#include <pthread.h>
+#include <dirent.h>
+#include <dlfcn.h>
+#include <libgen.h>
+#include <string>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "BlackmagicRawAPI.h"
+
+#define kBlackmagicRawAPI_Name "libBlackmagicRawAPI.so"
+#define kBlackmagicRawAPI_LibraryFolder "BlackmagicRawAPI"
+
+class BmdMutex
+{
+public:
+    inline explicit BmdMutex() { pthread_mutex_init(&m_mutex, NULL); }
+    inline ~BmdMutex() { pthread_mutex_destroy(&m_mutex); }
+    inline void lock() { pthread_mutex_lock(&m_mutex); }
+    inline void unlock() { pthread_mutex_unlock(&m_mutex); }
+
+private:
+    pthread_mutex_t m_mutex;
+};
+
+class BmdScopedLock
+{
+public:
+    inline explicit BmdScopedLock(BmdMutex& mutex) : m_mutex(mutex) { m_mutex.lock(); }
+    inline ~BmdScopedLock() { m_mutex.unlock(); }
+
+private:
+    BmdMutex& m_mutex;
+};
+
+typedef IBlackmagicRawFactory* (*CreateRawFactoryFunc)(void);
+typedef HRESULT (*VariantInitFunc)(Variant*);
+typedef HRESULT (*VariantClearFunc)(Variant*);
+typedef SafeArray* (*SafeArrayCreateFunc)(BlackmagicRawVariantType, uint32_t, SafeArrayBound*);
+typedef HRESULT (*SafeArrayGetVartypeFunc)(SafeArray*, BlackmagicRawVariantType*);
+typedef HRESULT (*SafeArrayGetLBoundFunc)(SafeArray*, uint32_t, long*);
+typedef HRESULT (*SafeArrayGetUBoundFunc)(SafeArray*, uint32_t, long*);
+typedef HRESULT (*SafeArrayAccessDataFunc)(SafeArray*, void**);
+typedef HRESULT (*SafeArrayUnaccessDataFunc)(SafeArray*);
+typedef HRESULT (*SafeArrayDestroyFunc)(SafeArray*);
+
+static CreateRawFactoryFunc                 gCreateBlackmagicRawFactoryInstance     = NULL;
+static VariantInitFunc                      gVariantInit                            = NULL;
+static VariantClearFunc                     gVariantClear                           = NULL;
+static SafeArrayCreateFunc                  gSafeArrayCreate                        = NULL;
+static SafeArrayGetVartypeFunc              gSafeArrayGetVartype                    = NULL;
+static SafeArrayGetLBoundFunc               gSafeArrayGetLBound                     = NULL;
+static SafeArrayGetUBoundFunc               gSafeArrayGetUBound                     = NULL;
+static SafeArrayAccessDataFunc              gSafeArrayAccessData                    = NULL;
+static SafeArrayUnaccessDataFunc            gSafeArrayUnaccessData                  = NULL;
+static SafeArrayDestroyFunc                 gSafeArrayDestroy                       = NULL;
+
+static BmdMutex                             gBlackmagicRawMutex;
+
+static void InitBlackmagicRawAPI (const char* libraryFilePath)
+{
+    void* libraryHandle;
+
+    libraryHandle = dlopen(libraryFilePath, RTLD_NOW|RTLD_GLOBAL);
+    if (!libraryHandle)
+    {
+        fprintf(stderr, "%s\n", dlerror());
+        return;
+    }
+
+    gCreateBlackmagicRawFactoryInstance = (CreateRawFactoryFunc)dlsym(libraryHandle, "CreateBlackmagicRawFactoryInstance");
+    if (!gCreateBlackmagicRawFactoryInstance)
+        fprintf(stderr, "%s\n", dlerror());
+    gVariantInit = (VariantInitFunc)dlsym(libraryHandle, "VariantInit");
+    if (!gVariantInit)
+        fprintf(stderr, "%s\n", dlerror());
+    gVariantClear = (VariantClearFunc)dlsym(libraryHandle, "VariantClear");
+    if (!gVariantClear)
+        fprintf(stderr, "%s\n", dlerror());
+    gSafeArrayCreate = (SafeArrayCreateFunc)dlsym(libraryHandle, "SafeArrayCreate");
+    if (!gSafeArrayCreate)
+        fprintf(stderr, "%s\n", dlerror());
+    gSafeArrayGetVartype = (SafeArrayGetVartypeFunc)dlsym(libraryHandle, "SafeArrayGetVartype");
+    if (!gSafeArrayGetVartype)
+        fprintf(stderr, "%s\n", dlerror());
+    gSafeArrayGetLBound = (SafeArrayGetLBoundFunc)dlsym(libraryHandle, "SafeArrayGetLBound");
+    if (!gSafeArrayGetLBound)
+        fprintf(stderr, "%s\n", dlerror());
+    gSafeArrayGetUBound = (SafeArrayGetUBoundFunc)dlsym(libraryHandle, "SafeArrayGetUBound");
+    if (!gSafeArrayGetUBound)
+        fprintf(stderr, "%s\n", dlerror());
+    gSafeArrayAccessData = (SafeArrayAccessDataFunc)dlsym(libraryHandle, "SafeArrayAccessData");
+    if (!gSafeArrayAccessData)
+        fprintf(stderr, "%s\n", dlerror());
+    gSafeArrayUnaccessData = (SafeArrayUnaccessDataFunc)dlsym(libraryHandle, "SafeArrayUnaccessData");
+    if (!gSafeArrayUnaccessData)
+        fprintf(stderr, "%s\n", dlerror());
+    gSafeArrayDestroy = (SafeArrayDestroyFunc)dlsym(libraryHandle, "SafeArrayDestroy");
+    if (!gSafeArrayDestroy)
+        fprintf(stderr, "%s\n", dlerror());
+}
+
+IBlackmagicRawFactory* CreateBlackmagicRawFactoryInstance (void)
+{
+    IBlackmagicRawFactory* factory = NULL;
+
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+    {
+        factory = CreateBlackmagicRawFactoryInstanceFromExeRelativePath(kBlackmagicRawAPI_LibraryFolder);
+        if (factory != NULL)
+            return factory;
+    }
+
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+    {
+        factory = CreateBlackmagicRawFactoryInstanceFromExeRelativePath(NULL);
+        if (factory != NULL)
+            return factory;
+    }
+
+    BmdScopedLock lock(gBlackmagicRawMutex);
+
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        InitBlackmagicRawAPI(kBlackmagicRawAPI_Name);
+
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return NULL;
+
+    return gCreateBlackmagicRawFactoryInstance();
+}
+
+IBlackmagicRawFactory* CreateBlackmagicRawFactoryInstanceFromPath (const char* loadPath)
+{
+    BmdScopedLock lock(gBlackmagicRawMutex);
+
+    // Load from desired folder
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+    {
+        std::string libraryFilePath(loadPath);
+        if ((! libraryFilePath.empty()) && (libraryFilePath.back() != '/'))
+            libraryFilePath += '/';
+        libraryFilePath += kBlackmagicRawAPI_Name;
+
+        InitBlackmagicRawAPI(libraryFilePath.c_str());
+    }
+
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return NULL;
+
+    return gCreateBlackmagicRawFactoryInstance();
+}
+
+IBlackmagicRawFactory* CreateBlackmagicRawFactoryInstanceFromExeRelativePath (const char* loadPath)
+{
+    BmdScopedLock lock(gBlackmagicRawMutex);
+
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+    {
+        char path[PATH_MAX + 1];
+        ssize_t count = readlink("/proc/self/exe", path, PATH_MAX);
+        if (count == 0)
+            return NULL;
+
+        path[count] = '\0';
+
+        char resolvedPath[PATH_MAX + 1];
+        char* absolutePathName = realpath(path, resolvedPath);
+        if (absolutePathName == NULL)
+            return NULL;
+
+        char* absoluteDirectory = dirname(absolutePathName);
+
+        std::string libraryFilePath(absoluteDirectory);
+
+        if (loadPath != NULL)
+        {
+            std::string loadPathString(loadPath);
+
+            if ((! loadPathString.empty()) && (loadPathString.front() != '/'))
+                libraryFilePath += '/';
+
+            libraryFilePath += loadPathString;
+        }
+
+        if ((! libraryFilePath.empty()) && (libraryFilePath.back() != '/'))
+            libraryFilePath += '/';
+        libraryFilePath += kBlackmagicRawAPI_Name;
+
+        InitBlackmagicRawAPI(libraryFilePath.c_str());
+    }
+
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return NULL;
+
+    return gCreateBlackmagicRawFactoryInstance();
+}
+
+HRESULT VariantInit (Variant* variant)
+{
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return E_FAIL;
+
+    return gVariantInit(variant);
+}
+
+HRESULT VariantClear (Variant* variant)
+{
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return E_FAIL;
+
+    return gVariantClear(variant);
+}
+
+SafeArray* SafeArrayCreate (BlackmagicRawVariantType variantType, uint32_t dimensions, SafeArrayBound* safeArrayBound)
+{
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return NULL;
+
+    return gSafeArrayCreate(variantType, dimensions, safeArrayBound);
+}
+
+HRESULT SafeArrayGetVartype (SafeArray* safeArray, BlackmagicRawVariantType* variantType)
+{
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return E_FAIL;
+
+    return gSafeArrayGetVartype(safeArray, variantType);
+}
+
+HRESULT SafeArrayGetLBound (SafeArray* safeArray, uint32_t dimensions, long* lBound)
+{
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return E_FAIL;
+
+    return gSafeArrayGetLBound(safeArray, dimensions, lBound);
+}
+
+HRESULT SafeArrayGetUBound (SafeArray* safeArray, uint32_t dimensions, long* uBound)
+{
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return E_FAIL;
+
+    return gSafeArrayGetUBound(safeArray, dimensions, uBound);
+}
+
+HRESULT SafeArrayAccessData (SafeArray* safeArray, void** outData)
+{
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return E_FAIL;
+
+    return gSafeArrayAccessData(safeArray, outData);
+}
+
+HRESULT SafeArrayUnaccessData (SafeArray* safeArray)
+{
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return E_FAIL;
+
+    return gSafeArrayUnaccessData(safeArray);
+}
+
+HRESULT SafeArrayDestroy (SafeArray* safeArray)
+{
+    if (gCreateBlackmagicRawFactoryInstance == NULL)
+        return E_FAIL;
+
+    return gSafeArrayDestroy(safeArray);
+}
diff -ruN '--exclude=.git' oiio-2.0.10/src/braw.imageio/brawinput.cpp oiio/src/braw.imageio/brawinput.cpp
--- oiio-2.0.10/src/braw.imageio/brawinput.cpp	1970-01-01 01:00:00.000000000 +0100
+++ oiio/src/braw.imageio/brawinput.cpp	2020-02-18 14:33:41.091257463 +0000
@@ -0,0 +1,558 @@
+/*
+ Created by Linas Beresna.
+ */
+
+#include "BlackmagicRawAPI.h"
+
+#include <OpenImageIO/dassert.h>
+#include <OpenImageIO/fmath.h>
+#include <OpenImageIO/imageio.h>
+#include <OpenImageIO/strutil.h>
+#include <OpenImageIO/typedesc.h>
+
+#include <boost/filesystem.hpp>
+namespace filesystem = boost::filesystem;
+// FIXME: use std::filesystem when available
+
+#include <vector>
+
+#define DEBUG 0
+
+OIIO_PLUGIN_NAMESPACE_BEGIN
+
+class CameraCodecCallback;
+
+class BrawInput final : public ImageInput {
+    public:
+        BrawInput() { init(); }
+        virtual ~BrawInput() { close(); }
+        virtual const char* format_name(void) const override { return "braw"; }
+        virtual bool open(const std::string& name, ImageSpec& newspec) override;
+        virtual bool close() override;
+    virtual int supports(string_view feature) const override
+    {
+        return (feature == "exif");
+    }
+        virtual int current_subimage(void) const override
+        {
+            lock_guard lock(m_mutex);
+            return m_subimage;
+        }
+        virtual bool seek_subimage(int subimage, int miplevel) override;
+        virtual bool read_native_scanline(int subimage, int miplevel, int y, int z,
+                void* data) override;
+        void storeImageData(void* imageData);
+        bool readFrame(uint64_t frameIndex);
+        bool getMetadata(ImageSpec &spec);
+
+    private:
+        CameraCodecCallback* m_callback;
+        IBlackmagicRawFactory* m_factory;
+        IBlackmagicRaw* m_codec;
+        IBlackmagicRawClip* m_clip;
+
+        long int m_number_channels;
+        uint64_t m_frame_count;
+        float m_frame_rate;
+        uint32_t m_width;
+        uint32_t m_height;
+        std::vector<unsigned char> m_imageData;
+        int m_subimage;
+        bool m_read_frame;
+        int64_t m_nsubimages;
+        uint64_t m_frame_index;
+
+        /// Reset everything to initial state
+        void init()
+        {
+            m_callback        = nullptr;
+            m_factory           = nullptr;
+            m_codec           = nullptr;
+            m_clip            = nullptr;
+            m_number_channels = 0;
+            m_width           = 0;
+            m_height          = 0;
+            m_frame_count       = 0;
+            m_frame_rate      = 0;
+            m_subimage        = 0;
+            m_frame_index     = 0;
+            m_read_frame      = false;
+            m_imageData.clear();
+        }
+
+};
+
+// Obligatory material to make this a recognizeable imageio plugin:
+OIIO_PLUGIN_EXPORTS_BEGIN
+
+    OIIO_EXPORT ImageInput*
+braw_input_imageio_create()
+{
+    return new BrawInput;
+}
+
+OIIO_EXPORT int braw_imageio_version = OIIO_PLUGIN_VERSION;
+
+    OIIO_EXPORT const char*
+braw_imageio_library_version()
+{
+    return nullptr;
+}
+
+OIIO_EXPORT const char* braw_input_extensions[] = { "braw", nullptr };
+
+OIIO_PLUGIN_EXPORTS_END
+
+////////////////////////////////////////////////////////////////////////
+/////// Callback class to get data from BlackmagicRAWAPI ///////////////
+////////////////////////////////////////////////////////////////////////
+class CameraCodecCallback : public IBlackmagicRawCallback
+{
+    public:
+        explicit CameraCodecCallback(BrawInput* brawInput) : m_brawInput(brawInput) {}
+        virtual ~CameraCodecCallback()
+        {
+            if(m_frame != nullptr)
+                m_frame->Release();
+        }
+
+        IBlackmagicRawFrame* GetFrame() { return m_frame; }
+
+        virtual void ReadComplete(IBlackmagicRawJob* readJob, HRESULT result, IBlackmagicRawFrame* frame)
+        {
+            IBlackmagicRawJob* decodeAndProcessJob = nullptr;
+
+            if(result == S_OK) {
+                m_frame = frame;
+                m_frame->AddRef();
+            }
+
+            if (result == S_OK)
+                result = frame->CreateJobDecodeAndProcessFrame(nullptr, nullptr, &decodeAndProcessJob);
+
+            if (result == S_OK)
+                result = decodeAndProcessJob->Submit();
+
+            if (result != S_OK) {
+                if (decodeAndProcessJob)
+                    decodeAndProcessJob->Release();
+            }
+
+            readJob->Release();
+        }
+
+        virtual void ProcessComplete(IBlackmagicRawJob* job, HRESULT result, IBlackmagicRawProcessedImage* processedImage)
+        {
+            void* imageData = nullptr;
+
+            if (result == S_OK)
+                result = processedImage->GetResource(&imageData);
+
+            if (result == S_OK) {
+                m_brawInput->storeImageData(imageData);
+            }
+
+            job->Release();
+        }
+
+        virtual void DecodeComplete(IBlackmagicRawJob*, HRESULT) {}
+        virtual void TrimProgress(IBlackmagicRawJob*, float) {}
+        virtual void TrimComplete(IBlackmagicRawJob*, HRESULT) {}
+        virtual void SidecarMetadataParseWarning(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
+        virtual void SidecarMetadataParseError(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
+        virtual void PreparePipelineComplete(void*, HRESULT) {}
+
+        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID*)
+        {
+            return E_NOTIMPL;
+        }
+
+        virtual ULONG STDMETHODCALLTYPE AddRef(void)
+        {
+            return 0;
+        }
+
+        virtual ULONG STDMETHODCALLTYPE Release(void)
+        {
+            return 0;
+        }
+    private:
+        BrawInput* m_brawInput;
+        IBlackmagicRawFrame* m_frame = nullptr;
+};
+
+//////////////////////////////////////////////////////////////////////////
+///////////////////// BrawInput Plugic Functions /////////////////////////
+//////////////////////////////////////////////////////////////////////////
+
+    bool
+BrawInput::open(const std::string& name, ImageSpec& newspec)
+{
+#ifdef BRAW_LIBRARIES
+#define STRINGIFY2(X) #X
+#define STRINGIFY(X) STRINGIFY2(X)
+#else
+#if DEBUG
+    std::cerr << "BRAW_LIBRARIES are not defined, therefore cannot construct BlackmagicRawFactory\n";
+#endif
+    return false;
+#endif
+
+    filesystem::path lib_path(STRINGIFY(BRAW_LIBRARIES));
+
+    m_number_channels = 4;  // Black magic has 4 channels?
+
+    HRESULT result = S_OK;
+
+    m_factory = CreateBlackmagicRawFactoryInstanceFromPath(lib_path.parent_path().c_str());
+    if (m_factory == nullptr) {
+#if DEBUG
+        std::cerr << "Failed to create IBlackmagicRawFactory!" << std::endl;
+#endif
+        return false;
+    }
+
+    result = m_factory->CreateCodec(&m_codec);
+    if (result != S_OK) {
+#if DEBUG
+        std::cerr << "Failed to create IBlackmagicRaw!" << std::endl;
+#endif
+        return false;
+    }
+
+    result = m_codec->OpenClip(name.c_str(), &m_clip);
+    if (result != S_OK) {
+#if DEBUG
+        std::cerr << "Failed to open IBlackmagicRawClip!" << std::endl;
+#endif
+        return false;
+    }
+
+    // Get basic data from the clip
+    m_clip->GetWidth(&m_width);
+    m_clip->GetHeight(&m_height);
+    m_clip->GetFrameCount(&m_frame_count);
+    m_clip->GetFrameRate(&m_frame_rate);
+
+    // Set callback class
+    m_callback = new CameraCodecCallback(this);
+    result = m_codec->SetCallback(m_callback);
+    if (result != S_OK) {
+#if DEBUG
+        std::cerr << "Failed to set IBlackmagicRawCallback!" << std::endl;
+#endif
+        return false;
+    }
+
+    m_spec = ImageSpec((int)m_width, (int)m_height, m_number_channels, TypeDesc::UINT8);
+    newspec = m_spec;
+    newspec.alpha_channel = 4;
+    newspec.attribute("oiio:ColorSpace", "linear");
+    newspec.attribute("oiio:Movie", true);
+
+    m_nsubimages = m_frame_count;
+
+    IBlackmagicRawClipProcessingAttributes* clipProcessingAttributes = nullptr;
+
+    // std::cerr << "\n";
+    // getMetadata(newspec);
+    // std::cerr << "\n";
+
+#if DEBUG
+    std::cerr << "Width: " << m_width
+        << "\nHeight: " << m_height
+        << "\nFrame Count: " << m_frame_count
+        << "\nFrame Rate: " << m_frame_rate << "\n";
+#endif
+
+    return true;
+}
+
+bool
+BrawInput::getMetadata(ImageSpec &spec)
+{
+    // Metadata
+    IBlackmagicRawMetadataIterator* clipMetadataIterator = nullptr;
+    const char *key = nullptr;
+    Variant value;
+
+    HRESULT result = m_clip->GetMetadataIterator(&clipMetadataIterator);
+    if (result != S_OK) {
+#if DEBUG
+        std::cerr << "Failed to get metdata iterator\n";
+#endif
+        return false;
+    }
+
+    while (SUCCEEDED(clipMetadataIterator->GetKey(&key))) {
+        std::cerr << "Key - " << key << ": value - ";
+        VariantInit(&value);
+
+        result = clipMetadataIterator->GetData(&value);
+        if (result != S_OK)
+        {
+#if DEBUG
+            std::cerr << "Failed to get data from IBlackmagicRawMetadataIterator!" << std::endl;}
+#endif
+            break;
+        }
+
+        BlackmagicRawVariantType variantType = value.vt;
+        switch (variantType)
+        {
+            case blackmagicRawVariantTypeS16:
+            {
+                short s16 = value.iVal;
+                std::cout << s16;
+            }
+            break;
+            case blackmagicRawVariantTypeU16:
+            {
+                unsigned short u16 = value.uiVal;
+                std::cout << u16;
+            }
+            break;
+            case blackmagicRawVariantTypeS32:
+            {
+                int i32 = value.intVal;
+                std::cout << i32;
+            }
+            break;
+            case blackmagicRawVariantTypeU32:
+            {
+                unsigned int u32 = value.uintVal;
+                std::cout << u32;
+            }
+            break;
+            case blackmagicRawVariantTypeFloat32:
+            {
+                float f32 = value.fltVal;
+                std::cout << f32;
+            }
+            break;
+            case blackmagicRawVariantTypeString:
+            {
+                std::cout << value.bstrVal;
+            }
+            break;
+            case blackmagicRawVariantTypeSafeArray:
+            {
+                SafeArray* safeArray = value.parray;
+
+                void* safeArrayData = nullptr;
+                result = SafeArrayAccessData(safeArray, &safeArrayData);
+                if (result != S_OK)
+                {
+#if DEBUG
+                    std::cerr << "Failed to access safeArray data!" << std::endl;
+#endif
+                    break;
+                }
+
+                BlackmagicRawVariantType arrayVarType;
+                result = SafeArrayGetVartype(safeArray, &arrayVarType);
+                if (result != S_OK)
+                {
+#if DEBUG
+                    std::cerr << "Failed to get BlackmagicRawVariantType from safeArray!" << std::endl;
+#endif
+                    break;
+                }
+
+                long lBound;
+                result = SafeArrayGetLBound(safeArray, 1, &lBound);
+                if (result != S_OK)
+                {
+#if DEBUG
+                    std::cerr << "Failed to get LBound from safeArray!" << std::endl;
+#endif
+                    break;
+                }
+
+                long uBound;
+                result = SafeArrayGetUBound(safeArray, 1, &uBound);
+                if (result != S_OK)
+                {
+#if DEBUG
+                    std::cerr << "Failed to get UBound from safeArray!" << std::endl;
+#endif
+                    break;
+                }
+
+                long safeArrayLength = (uBound - lBound) + 1;
+                long arrayLength = safeArrayLength > 32 ? 32 : safeArrayLength;
+
+                for (int i = 0; i < arrayLength; ++i)
+                {
+                    switch (arrayVarType)
+                    {
+                        case blackmagicRawVariantTypeU8:
+                        {
+                            int u8 = static_cast<int>(static_cast<unsigned char*>(safeArrayData)[i]);
+                        if (i > 0)
+                            std::cout << ",";
+                        std::cout << u8;
+                        }
+                        break;
+                        case blackmagicRawVariantTypeS16:
+                        {
+                            short s16 = static_cast<short*>(safeArrayData)[i];
+                            std::cout << s16 << " ";
+                        }
+                        break;
+                        case blackmagicRawVariantTypeU16:
+                        {
+                            unsigned short u16 = static_cast<unsigned short*>(safeArrayData)[i];
+                            std::cout << u16 << " ";
+                        }
+                        break;
+                        case blackmagicRawVariantTypeS32:
+                        {
+                            int i32 = static_cast<int*>(safeArrayData)[i];
+                            std::cout << i32 << " ";
+                        }
+                        break;
+                        case blackmagicRawVariantTypeU32:
+                        {
+                            unsigned int u32 = static_cast<unsigned int*>(safeArrayData)[i];
+                            std::cout << u32 << " ";
+                        }
+                        break;
+                        case blackmagicRawVariantTypeFloat32:
+                        {
+                            float f32 = static_cast<float*>(safeArrayData)[i];
+                            std::cout << f32 << " ";
+                        }
+                        break;
+                        default:
+                            break;
+                    }
+                }
+            }
+            default:
+                break;
+        }
+
+        VariantClear(&value);
+
+        std::cout << std::endl;
+
+        clipMetadataIterator->Next();
+    }
+
+    if(clipMetadataIterator != nullptr)
+        clipMetadataIterator->Release();
+    return true;
+}
+
+    bool
+BrawInput::close()
+{
+    if(m_clip != nullptr)
+        m_clip->Release();
+    if(m_codec != nullptr)
+        m_codec->Release();
+    if(m_factory != nullptr)
+        m_factory->Release();
+    if(m_callback != nullptr)
+        delete m_callback;
+
+    init();
+
+    return true;
+}
+
+    bool
+BrawInput::seek_subimage(int subimage, int miplevel)
+{
+    if (subimage < 0 || subimage >= m_nsubimages || miplevel > 0) {
+        return false;
+    }
+    if (subimage == m_subimage) {
+        return true;
+    }
+    m_subimage   = subimage;
+    m_read_frame = false;
+    return true;
+}
+
+    bool
+BrawInput::read_native_scanline(int subimage, int miplevel, int y, int z,
+        void* data)
+{
+    lock_guard lock(m_mutex);
+
+    if (!seek_subimage(subimage, miplevel))
+        return false;
+    if(!m_read_frame) {
+        if(!readFrame(m_subimage))
+            return false;
+    }
+
+    if (y < 0 || y >= m_spec.height)  // out of range scanline
+        return false;
+
+    memcpy(data, &m_imageData[y * m_spec.width * m_spec.nchannels],
+            m_spec.width * m_spec.nchannels);
+
+    return true;
+}
+
+    bool
+BrawInput::readFrame(uint64_t frameIndex)
+{
+    HRESULT result = S_OK;
+    IBlackmagicRawJob* readJob = nullptr;
+
+    result = m_clip->CreateJobReadFrame(frameIndex, &readJob);
+    if (result != S_OK) {
+#if DEBUG
+        std::cerr << "Failed to create IBlackmagicRawJob!" << std::endl;
+#endif
+        return false;
+    }
+
+    result = readJob->Submit();
+    if (result != S_OK) {
+        readJob->Release();
+#if DEBUG
+        std::cerr << "Failed to submit IBlackmagicRawJob!" << std::endl;
+#endif
+        return false;
+    }
+    m_codec->FlushJobs();
+
+    m_read_frame = true;
+
+    return true;
+}
+
+    void
+BrawInput::storeImageData(void* imageData)
+{
+    m_imageData.resize(m_width * m_height * m_number_channels);
+    std::fill(m_imageData.begin(), m_imageData.end(), 0x00);
+
+    unsigned char* rgba = (unsigned char*)imageData;
+    for (int y = 0; y <= (int)m_height-1; y++)
+    {
+        for (int x = 0; x < (int)m_width; x++)
+        {
+            unsigned char red   = rgba[0];
+            unsigned char green = rgba[1];
+            unsigned char blue  = rgba[2];
+            unsigned char alpha = rgba[3];
+
+            int idx = m_number_channels * (y * m_width + x);
+            m_imageData[idx]     = red;
+            m_imageData[idx + 1] = green;
+            m_imageData[idx + 2] = blue;
+            m_imageData[idx + 3] = alpha;
+
+            rgba += 4; // next 4
+
+        }
+    }
+}
+
+    OIIO_PLUGIN_NAMESPACE_END
diff -ruN '--exclude=.git' oiio-2.0.10/src/braw.imageio/CMakeLists.txt oiio/src/braw.imageio/CMakeLists.txt
--- oiio-2.0.10/src/braw.imageio/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ oiio/src/braw.imageio/CMakeLists.txt	2020-02-18 14:33:41.091257463 +0000
@@ -0,0 +1,10 @@
+if (USE_BRAW AND BRAW_FOUND)
+    message (STATUS "Building braw plugin")
+    add_oiio_plugin (brawinput.cpp BlackmagicRawAPIDispatch.cpp
+        INCLUDE_DIRS ${BRAW_INCLUDE_DIR}
+        LINK_LIBRARIES ${BRAW_LIBRARIES}
+        DEFINITIONS "-DUSE_BRAW=1")
+else ()
+    message (WARNING "braw plugin will not be built")
+endif ()
+
diff -ruN '--exclude=.git' oiio-2.0.10/src/cmake/externalpackages.cmake oiio/src/cmake/externalpackages.cmake
--- oiio-2.0.10/src/cmake/externalpackages.cmake	2020-02-18 12:09:43.621572779 +0000
+++ oiio/src/cmake/externalpackages.cmake	2020-02-18 14:33:41.092257462 +0000
@@ -4,6 +4,7 @@
 # When not in VERBOSE mode, try to make things as quiet as possible
 if (NOT VERBOSE)
     set (Boost_FIND_QUIETLY true)
+    set (BRAW_FIND_QUIETLY false)
     set (DCMTK_FIND_QUIETLY true)
     set (FFmpeg_FIND_QUIETLY true)
     set (Field3D_FIND_QUIETLY true)
@@ -137,6 +138,32 @@
 ###########################################################################
 
 ###########################################################################
+# braw setup
+
+if (USE_BRAW)
+    if (NOT BRAW_FIND_QUIETLY)
+        message (STATUS "Looking for braw with ${BRAW_PATH}")
+    endif ()
+    find_package (braw)
+    if (BRAW_LIBRARIES AND BRAW_INCLUDE_DIR)
+        set (BRAW_FOUND TRUE)
+        include_directories (${BRAW_INCLUDE_DIR})
+        add_definitions (-DBRAW_LIBRARIES=${BRAW_LIBRARIES})
+        if (NOT BRAW_FIND_QUIETLY)
+            message (STATUS "Found braw, include path ${BRAW_INCLUDE_DIR} and lib path ${BRAW_LIBRARIES}")
+        endif ()
+    else ()
+        set (BRAW_FOUND FALSE)
+        message (STATUS "braw not found!")
+    endif()
+else ()
+    message (STATUS "Not using braw")
+endif()
+
+# end braw setup
+###########################################################################
+
+###########################################################################
 # OpenGL setup
 
 if (USE_OPENGL)
diff -ruN '--exclude=.git' oiio-2.0.10/src/cmake/modules/Findbraw.cmake oiio/src/cmake/modules/Findbraw.cmake
--- oiio-2.0.10/src/cmake/modules/Findbraw.cmake	1970-01-01 01:00:00.000000000 +0100
+++ oiio/src/cmake/modules/Findbraw.cmake	2020-02-18 14:33:41.107257447 +0000
@@ -0,0 +1,54 @@
+# - Find braw
+# Find the LibRaw library <http://www.libraw.org>
+# This module defines
+#  BRAW_INCLUDE_DIR, where to find the BlackmagicRAWAPI.h
+#  BRAW_LIBRARIES, the libraries needed to use braw
+#  BRAW_DEFINITIONS, the definitions needed to use braw
+#
+# Copyright (c) 2020, Linas Beresna <beres dot linas at gmail dot com>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+FIND_PACKAGE(PkgConfig)
+
+IF(PKG_CONFIG_FOUND AND NOT BRAW_PATH)
+    PKG_CHECK_MODULES(PC_BRAW QUIET braw)
+    SET(BRAW_DEFINITIONS ${PC_LIBRAW_CFLAGS_OTHER})
+
+ENDIF()
+
+FIND_PATH(BRAW_INCLUDE_DIR BlackmagicRawAPI.h   # LinuxCOM.h must also be present
+    HINTS
+    ${BRAW_INCLUDEDIR_HINT}
+    ${BRAW_PATH}
+    ${BRAW_INCLUDE_PATH}
+    ${PC_BRAW_INCLUDEDIR}
+    ${PC_BRAW_INCLUDE_DIRS}
+    PATH_SUFFIXES libraw
+    )
+
+# BlackmagicRAW also requires libc++ and libc++abi
+
+FIND_LIBRARY(BRAW_LIBRARIES NAMES braw libBlackmagicRawAPI BlackmagicRawAPI
+    HINTS
+    ${BRAW_LIBDIR_HINT}
+    ${BRAW_PATH}
+    ${PC_BRAW_LIBDIR}
+    ${PC_BRAW_LIBRARY_DIRS}
+    )
+
+# BlackmagicRAW doesn't seem to have information about versioning...
+# Will have to continue to check their website to see if there are any versioning going on
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(braw
+    REQUIRED_VARS BRAW_LIBRARIES BRAW_INCLUDE_DIR
+    VERSION_VAR BRAW_VERSION_STRING
+    )
+
+MARK_AS_ADVANCED(BRAW_VERSION_STRING
+    BRAW_INCLUDE_DIR
+    BRAW_LIBRARIES
+    BRAW_DEFINITIONS
+    )
diff -ruN '--exclude=.git' oiio-2.0.10/src/libOpenImageIO/imageioplugin.cpp oiio/src/libOpenImageIO/imageioplugin.cpp
--- oiio-2.0.10/src/libOpenImageIO/imageioplugin.cpp	2020-02-18 12:09:43.622572778 +0000
+++ oiio/src/libOpenImageIO/imageioplugin.cpp	2020-02-18 14:33:41.156257401 +0000
@@ -234,6 +234,7 @@
         extern const char* name##_imageio_library_version();
 
 PLUGENTRY(bmp);
+PLUGENTRY_RO(braw);
 PLUGENTRY(cineon);
 PLUGENTRY(dds);
 PLUGENTRY_RO(dicom);
@@ -293,6 +294,9 @@
             name##_imageio_library_version())
 
     DECLAREPLUG (bmp);
+#ifdef USE_BRAW
+    DECLAREPLUG_RO (braw);
+#endif
     DECLAREPLUG_RO (cineon);
     DECLAREPLUG_RO (dds);
 #ifdef USE_DCMTK
